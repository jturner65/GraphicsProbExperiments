package graphProbExp_PKG;

import java.util.*;

/**
 * instances of this class will analyze and display statistical results relating to a data set;  this will also provide an easy-access container to manage moments
 * @author john
 *
 */
public class myProbSummary{
	//values to analyze
	private double[] vals;
	//(population) moments of this distribution.  mean, std, var may be null/undefined for certain distributions (i.e. cauchy)
	protected double[] mmnts;
	//min and max values of data
	protected double[] minMax;
	//multipliers to derive sample moments from population moments
	protected double[] popToSmplMmntMults;
	//flags holding state information about this summary object
	//state flags - bits in array holding relevant info about this random variable function
	private int[] stFlags;						
	public static final int 
		meanIDX				= 0, 
		stdIDX				= 1, 
		skewIDX				= 2,
		kurtIDX				= 3,
		//insert any higher moments in here
		//these are convenience calcs/transforms of base moment values
		varIDX				= 4,
		excKurtIDX			= 5,
		//
		setByDataIDX		= 6,				//whether the moments values in this object were set by data or were set specifically
		smplValsCalcedIDX 	= 7,				//sample moments calculated for a specific sample size
		clipAllSmplsIDX		= 8;				//all samples should be clipped to given min/max values
	//# of boolean flags
	public static final int numFlags = 9;
	//# of moments being tracked, excluding variance and excess kurtosis and other duped moments
	public static final int numMmnts = 6;
	//# of samples, if sample size set
	private int sampleSize;
	//# of moments actually specified, not counting derived moments
	public int numMmntsGiven;
	
	public static final String[] mmntLabels = new String[] {"Mean","STD","Skew","Kurtosis", "Variance","Excess Kurtosis"};
	
	//dataset is passed
	public myProbSummary(double[] _data) {
		updateVals(_data);		
	}//ctor
	
	//momments are passed - no sample data exists
	//numMmnts are # of moments actually specified
	public myProbSummary(double[] _mmnts, int _numMmnts, boolean isExKurt) {
		initFlags();
		setMoments(_mmnts, _numMmnts, isExKurt);		
	}//ctor
	//if not specified then assume kurtosis passed is not excess but rather actual 
	public myProbSummary(double[] _mmnts, int _numMmnts) {this(_mmnts,_numMmnts, false);}
	
	//build analysis of _data
	public void updateVals(double[] _data) {
		initFlags();
		setValsAndAnalyse(_data);
	}//updateVals
	
	//whether all samples generated by the function utilizing this summary should be clipped
	public boolean doClipAllSamples() {return getFlag(clipAllSmplsIDX);}
	public void setClipAllSamples(boolean val) {setFlag(clipAllSmplsIDX, val);}
	
	//using Kahan summation to minimize errors from large differences in value magnitude
	public void setValsAndAnalyse(double[] _vals) {
		setFlag(setByDataIDX, true);
		mmnts = new double[numMmnts];  
		popToSmplMmntMults = new double[numMmnts];
		for(int i=0;i<numMmnts;++i) {mmnts[i]=0.0;}
		vals=_vals;
		int numVals = vals.length;
		if(numVals ==0 ) {return;}
		///calculate mean while minimizing float error
		double sumMu = vals[0], min = vals[0], max = vals[0];
		double cMu = 0.0, y, t;
		for(int i=1;i<vals.length;++i) {
			min=(vals[i]<min?vals[i]:min);
			max=(vals[i]>max?vals[i]:max);
			
			y = vals[i] - cMu;
			t = sumMu + y;
			cMu = (t-sumMu) - y;
			sumMu = t;
		}//		
		mmnts[meanIDX] = sumMu/numVals;
		//calculate variance/std while minimizing float error
		//double sumVar = (vals[0] - mmnts[meanIDX])*(vals[0] - mmnts[meanIDX]);
		double tDiff, tDiffSq;
		double valMMean = (vals[0] - mmnts[meanIDX]);
		double [] sumAndCSq = new double[] {valMMean*valMMean, 0.0};
		double [] sumAndCCu = new double[] {(sumAndCSq[0])*valMMean, 0.0};
		double [] sumAndCQu = new double[] {(sumAndCSq[0])*(sumAndCSq[0]), 0.0};
		//kahan summation to address magnitude issues in adding 2 values of largely different magnitudes
		for(int i=1;i<vals.length;++i) {
			tDiff = vals[i] - mmnts[meanIDX];
			tDiffSq = (tDiff*tDiff);
			calcSumAndC(sumAndCSq,tDiffSq - sumAndCSq[1]);
			calcSumAndC(sumAndCCu,(tDiffSq*tDiff) - sumAndCCu[1]);
			calcSumAndC(sumAndCQu,(tDiffSq*tDiffSq) - sumAndCQu[1]);
		}//		
		mmnts[varIDX] = sumAndCSq[0] / numVals;
		mmnts[stdIDX] = Math.sqrt(mmnts[varIDX]);
		mmnts[skewIDX] = (sumAndCCu[0] / numVals)/(mmnts[stdIDX]*mmnts[varIDX]);
		mmnts[kurtIDX] = (sumAndCQu[0] / numVals)/(mmnts[varIDX]*mmnts[varIDX]);
		mmnts[excKurtIDX] = mmnts[kurtIDX]-3.0;
		
		for(int i=0;i<numMmnts;++i) {
			setFlag(i,true);
		}
		numMmntsGiven = 4;	
		//System.out.println("Data vals :  " + numVals + " var : " + mmnts[varIDX] + " std : " + mmnts[stdIDX] + " min : " + min + " | Max : " + max);
		calcSmpleMomentsForSampleSize(numVals,new double[] {min,max});
	}//setVals
	
	private void calcSumAndC(double[] sumAndC, double y) {
		double t = sumAndC[0] + y;
		sumAndC[1] = (t-sumAndC[0]) - y;
		sumAndC[0] = t;
	}
	
	//build buckets of equally space buckets and counts in buckets
	//returns array of numBuckets, 2, where idx 0 is lower xVal of bucket, and idx 1 is count in bucket - last element has idx0 == max bucket limit, count 0 (none above max)
	public double[][] calcBucketVals(int numBuckets){
		//if no data, return empty array - need data to calculate this
		if ((vals == null) || (vals.length == 0)) {return new double[0][0];}
		double[][] results = new double[numBuckets+1][2];
		//split min->max into numBuckets partitions
		double diff = minMax[1] - minMax[0];
		double bucketDiff = diff/numBuckets;
		for(int i=0; i<results.length;++i) {
			results[i][0] = minMax[0] + i * bucketDiff;
		}
		for (int i=0;i<vals.length;++i) {
			double bktVal = (vals[i]-minMax[0])/bucketDiff;
			int idx = (int)(bktVal);
			//System.out.println("IDX found for # bkts : " +numBuckets + " bktVal : " + bktVal +" idx : " + idx +" orig val : " + vals[i] + " min : " + minMax[0] +" max : "+ minMax[1]);
			++results[idx][1];	
		}		
		return results;
	}//calcBucketVals
	
	//this will force excess kurtosis to be passed value for fleishman polynomial
	//DANGER this may have unforseen effects, and should only be done with care.  this will require that sample vs. pop kurt values will be recalced, if data exists for them
	public void forceExKurt(double _exKurt) {
		mmnts[excKurtIDX] = _exKurt;
		mmnts[kurtIDX] = mmnts[excKurtIDX] + 3;
		setFlag(kurtIDX, true);
		setFlag(excKurtIDX, true);
		if(vals.length > 0) {			calcSmpleMomentsForSampleSize();		} 
		else {							setFlag(smplValsCalcedIDX, false);		}			
	}//forceExKurt
	
	public boolean checkInBnds(double x) {	return ((minMax[0] <= x) && (minMax[1] >= x));}
		
	//take passed moments (only canonical - no separate variance and ex kurtosis values) and set the internal moments of this analysis object
	//moments given are assumed to be of population, so sample multiplier is dependent on size of sample
	public void setMoments(double[] _mmnts, int _numMmntsGiven, boolean isExKurt) {
		vals = new double[0];
		setFlag(setByDataIDX, false);
		mmnts = new double[numMmnts];  
		setMinMax(Double.NEGATIVE_INFINITY,Double.POSITIVE_INFINITY);		
		popToSmplMmntMults = new double[numMmnts];
		numMmntsGiven = _numMmntsGiven;
		mmnts[meanIDX] = _mmnts[meanIDX];
		setFlag(meanIDX, true);
		if(numMmntsGiven > 1) {//has std
			mmnts[stdIDX] = _mmnts[stdIDX];
			setFlag(stdIDX, true);
			mmnts[varIDX]=mmnts[stdIDX]*mmnts[stdIDX];
			setFlag(varIDX, true);
			if(numMmntsGiven > 2) {//has skew
				mmnts[skewIDX] = _mmnts[skewIDX];
				setFlag(skewIDX, true);
				if(numMmntsGiven > 3) {//has kurtosis
					if (isExKurt) {
						mmnts[excKurtIDX] = _mmnts[kurtIDX];
						mmnts[kurtIDX] = mmnts[excKurtIDX] + 3;
						setFlag(kurtIDX, true);
						setFlag(excKurtIDX, true);
					} else {
						mmnts[kurtIDX] = _mmnts[kurtIDX];
						mmnts[excKurtIDX] = mmnts[kurtIDX]-3.0;
						setFlag(kurtIDX, true);
						setFlag(excKurtIDX, true);
					}
				}					
			}		
		}	
		setFlag(smplValsCalcedIDX, false);
	}//setMoments	
	
	//set desired bounds on any distribution built from this data
	public void setMinMax(double min, double max) {setMinMax(new double[] {min,max});}
	public void setMinMax(double[] _minMax) {	minMax = _minMax;}
	
	public void calcSmpleMomentsForSampleSize(){calcSmpleMomentsForSampleSize(vals.length, minMax);}
	//assuming calculated moments are population moments, modify popToSmpleMmntMults values so they can be used to calculate sample moments
	public void calcSmpleMomentsForSampleSize(int _smpleSize, double[] _minMax) {
		sampleSize = _smpleSize;
		popToSmplMmntMults = new double[numMmnts];
		setMinMax(_minMax[0],_minMax[1]);			
		popToSmplMmntMults[meanIDX] = 1.0;
		if(sampleSize <= 1) {return;}
		popToSmplMmntMults[varIDX] = sampleSize/(sampleSize-1);
		popToSmplMmntMults[stdIDX] =  Math.sqrt(popToSmplMmntMults[varIDX]);
		if(sampleSize <= 2) {return;}
		double smplSz2x = (sampleSize*sampleSize), sz1msz2 = (sampleSize-1)*(sampleSize-2);
		popToSmplMmntMults[skewIDX] = (smplSz2x/sz1msz2) / (popToSmplMmntMults[varIDX] * popToSmplMmntMults[stdIDX]); 
		if(sampleSize <= 3) {return;}
		popToSmplMmntMults[kurtIDX] = ((smplSz2x*(sampleSize+1))/(sz1msz2*(sampleSize-3))) / (popToSmplMmntMults[varIDX] * popToSmplMmntMults[varIDX]);
		popToSmplMmntMults[kurtIDX] = popToSmplMmntMults[kurtIDX];
		setFlag(smplValsCalcedIDX, true);
	}//calcSmpleMomentsForSampleSize
	
	public double mean() {return getFlag(meanIDX) ? mmnts[meanIDX] : 0;}
	public double var() { return getFlag(varIDX) ? mmnts[varIDX] : 0;}
	public double std() { return getFlag(stdIDX) ? mmnts[stdIDX] : 0;}
	public double skew() { return getFlag(skewIDX) ? mmnts[skewIDX] : 0;}
	public double kurt() { return getFlag(kurtIDX) ? mmnts[kurtIDX] : 0;}
	public double exKurt() { return getFlag(excKurtIDX) ? mmnts[excKurtIDX] : 0;}
	
	public double getMin() {return minMax[0];}
	public double getMax() {return minMax[1];}
	
	public double[] getDataVals() {return vals;}
	
	//get moments of sampled data, if specified that given moments are of underlying population
	public double smpl_mean() {return (getFlag(meanIDX) & getFlag(smplValsCalcedIDX)) ? mmnts[meanIDX] * popToSmplMmntMults[meanIDX]: 0;}
	public double smpl_var() { return (getFlag(varIDX) & getFlag(smplValsCalcedIDX))  ? mmnts[varIDX] * popToSmplMmntMults[varIDX]  : 0;}
	public double smpl_std() { return (getFlag(stdIDX) & getFlag(smplValsCalcedIDX))  ? mmnts[stdIDX] * popToSmplMmntMults[stdIDX] : 0;}
	public double smpl_skew() { return (getFlag(skewIDX) & getFlag(smplValsCalcedIDX))  ? mmnts[skewIDX] * popToSmplMmntMults[skewIDX] : 0;}
	public double smpl_kurt() { return (getFlag(kurtIDX) & getFlag(smplValsCalcedIDX))  ? mmnts[kurtIDX] * popToSmplMmntMults[kurtIDX] : 0;}
	public double smpl_exKurt() { return (getFlag(excKurtIDX) & getFlag(smplValsCalcedIDX))  ? mmnts[excKurtIDX] * popToSmplMmntMults[excKurtIDX] : 0;}
	
	//transform the given value via the 1st 2 moments of the distribution described by these statistics from a normal ~N(0,1) 
	public double normToGaussTransform(double val) {return (val * mmnts[stdIDX]) +  mmnts[meanIDX];}
	//transform the give value, assumed to be from the distribution described by this object, to a normal ~N(0,1) 
	public double gaussToNormTransform(double val) {return (val - mmnts[meanIDX])/ mmnts[stdIDX];}
		
	private void initFlags(){stFlags = new int[1 + numFlags/32]; for(int i = 0; i<numFlags; ++i){setFlag(i,false);}}
	public void setAllFlags(int[] idxs, boolean val) {for (int idx : idxs) {setFlag(idx, val);}}
	public void setFlag(int idx, boolean val){
		int flIDX = idx/32, mask = 1<<(idx%32);
		stFlags[flIDX] = (val ?  stFlags[flIDX] | mask : stFlags[flIDX] & ~mask);
		switch (idx) {//special actions for each flag
			case meanIDX	 		: {break;} 
			case stdIDX		 		: {break;} 
			case skewIDX			: {break;} 
			case kurtIDX			: {break;} 						
			case varIDX		 		: {break;} 
			case excKurtIDX			: {break;}
			case setByDataIDX		: {break;}
			case smplValsCalcedIDX	: {break;}			//whether multipliers to modify calculated pop moments to be appropriate sample moments have been calculated
		}
	}//setFlag		
	public boolean getFlag(int idx){int bitLoc = 1<<(idx%32);return (stFlags[idx/32] & bitLoc) == bitLoc;}		

	public String getMomentsVals() {
		String res = "# vals : " +vals.length + " | Set By Data : " + getFlag(setByDataIDX) + " | "  + getMoments();
		return res;
	}
	
	public String getMoments() {
		String res = "";
		for (int i=0;i<mmntLabels.length-1;++i) {	res +=  mmntLabels[i] + " = "+String.format("%.8f",mmnts[i]) + " | ";	}
		res+=mmntLabels[mmntLabels.length-1] + " = "+String.format("%.8f",mmnts[mmntLabels.length-1]);
		return res;
	}
	
	public String getMinNumMmntsDesc() {
		String res = "";
		for (int i=0;i<numMmntsGiven-1;++i) {	res +=  mmntLabels[i] + " = "+String.format("%.8f",mmnts[i]) + " | ";	}
		res+=mmntLabels[numMmntsGiven-1] + " = "+String.format("%.8f",mmnts[numMmntsGiven-1]);
		return res;
	}
	
	//get base moments with no descriptor strings
	public String getMinNumMmnts() {
		String res = "";
		for(int i=0;i<numMmntsGiven;++i) { 			res += "_"+String.format("%.5f",mmnts[i]);		}
		return res;
	}	

}//class myProbAnalysis
